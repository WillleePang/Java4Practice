package com.willlee.leetcode.problems1201_1300;

public class Leetcode1217 {
    // 根据题意抽象一下，就是第i个筹码移动偶数个位置代价是0，移动奇数位置代价是1。
    // 然而最终都可以落到1位置（奇数位置）或者2位置（偶数位置）。因为移动2格（即偶数个格子）不需要代价，所以原本在偶数位置的元素，可以不需要代价移动到2位置，
    // 而原本是奇数位置的元素可以不费代价的移动到1位置。 问题就转化为现在所有元素都在1号位置和2号位置了。1号位置代表是奇数位置的个数，
    // 2号位置代表的是偶数位置的个数。
    //
    // 题目问最小需要多少代价移动到同一个位置。那就看看是现在是要把1号位置的数全部放到2号位置，还是把2号位置的数全部放到1号位置。 要使得代价最小，
    // 肯定是看1号和2号哪个位置的元素个数少就把对应少的位置的所有元素移动到多的位置。每次移动的代价为1，
    // 及最少代价就是Min(1号位置个数， 2号位置个数)Min(1号位置个数，2号位置个数) ==
    // Min(奇数位置个数，偶数位置个数)Min(奇数位置个数，偶数位置个数)
    public int minCostToMoveChips(int[] chips) {
        int num1 = 0, num2 = 0;
        for (int i = 0; i < chips.length; i++) {
            if (chips[i] % 2 == 1) {
                num1++;
            } else {
                num2++;
            }
        }
        return Math.min(num1, num2);
    }
}
